# ウィンドウ関数
<br>

## ウィンドウ関数とは
OLAP（Online Analytical Processing, DBを使ってリアルタイムにデータ分析を行う処理のこと）
を実現するために実装された機能がウィンドウ関数。
例えば価格の低い順にランク付けをする、累計の合計値を出したい時などが主な使い道か？
<br>

## 使い方
### 構文
```sql
ウィンドウ関数 OVER (PARTITION BY フィールド
                ORDER BY ソート用フィールド)
```

### ウィンドウ関数として使える関数
1. 集約関数（SUM, AVG, COUNT, MAXなど）
2. RANK, DENSE_RANK, ROW_NUMBERなどのウィンドウ専用関数

PARTITION BY
対象の範囲を指定する。**ここで指定した範囲をウィンドウと呼ぶ。**イメージとしてはウィンドウ関数用のGROUP BY。
指定しない場合はテーブル全体に対してウィンドウ関数を使用する。

ORDER BY
どの順序でウィンドウ関数を適用するかを指定。

※ウィンドウ関数はWHERE句やGROUP BY句での処理が終わった結果に対して作用するように作られているため、
ウィンドウ関数は原則としてSELECT句でしか使えない。（ORDER BY句でも使えるか？）

### フレームを指定
フレームとは、ウィンドウの中でさらに集計範囲を細かく指定するオプション。
```sql
ウィンドウ関数 OVER (PARTITION BY フィールド
                ORDER BY フィールド
                ROWS 数値 PRECEDING) AS フィールド名 // PRECEDING or FOLLOWING
```
PARTITION BYで指定したウィンドウの中で、
ROWS 数値 PRECEDING で指定したレコード数分、カレントレコードの前後に対象範囲を絞る。

カレントレコードの前後両方を指定したい場合は以下のようにする。
```sql
ウィンドウ関数 OVER (PARTITION BY フィールド
                ORDER BY フィールド
                ROWS BETWEEN 数値 PRECEDING AND
                数値 FOLLOWING) AS フィールド名 // PRECEDING or FOLLOWING
```
<br>

## ウィンドウ関数の種類
1. RANK関数
ランキングを算出する。同じ順位が複数レコード存在した場合は後続の順位が飛ぶ。
例）1位が3レコードある場合は、1位,1位,1位,4位 ...となる。

2. DENSE_RANK関数
ランキングを算出するが、同順位が複数レコード存在していても後続の順位は飛ばない。
例）1位が3レコードある場合は、1位,1位,1位,2位 ...となる。

3. ROW_NUMBER関数
一位な連番を付与する。
例）1位が3レコードある場合は、1位,2位,3位 ...となる。
<br>

## 使い方例 -- RANK関数
以下のようなテーブルが存在している時、
各カテゴリごとに値段の低い順にランク付けしたい場合を考える。

Productsテーブル
|id|category|name|price|
|--|--|--|--|
|1|キッチン用品|フォーク|500|
|2|キッチン用品|包丁|3000|
|3|キッチン用品|まな板|880|
|4|衣類|シャツ|1000|
|5|衣類|パンツ|3000|
|5|事務用品|コピー用紙|600|
|5|事務用品|ボールペン|100|

```sql
SELECT name, category, price,
    RANK () OVER (PARTITION BY category
                    ORDER BY price) AS ranking
    FROM products;
```
とすると以下の結果が返る。
|category|name|price|ranking|
|--|--|--|--|
|キッチン用品|フォーク|500|1|
|キッチン用品|まな板|880|2|
|キッチン用品|包丁|3000|3|
|衣類|シャツ|1000|1|
|衣類|パンツ|3000|2|
|事務用品|ボールペン|100|1|
|事務用品|コピー用紙|600|2|

見てわかる通り、キッチン用品、衣類、事務用品の各カテゴリー内で価格の安い順に1~3位までが順位付けされている。

PARTITION BYでカテゴリごとに価格のランク付けをするよう指定している。
ORDER BYで価格の低い順にランク付けするよう指定している。
<br>

## 使い方例 -- 集積関数
```sql
SELECT id, name, price
    SUM(price) OVER (ORDER BY id) AS current_sum
FROM products;
```
結果は以下のように、「自分よりも小さい」idを持つレコードの価格を合計している。
そのため**累計**を表示することができる。
|id|name|price|current_sum|
|--|--|--|--|
|1|フォーク|500|500|
|2|包丁|3000|3500|
|3|まな板|880|4380|
|4|シャツ|1000|5380|
|5|パンツ|3000|8380|
|6|コピー用紙|600|8980|
|7|ボールペン|100|9080|
<br>

## 使い方例 -- 移動平均を算出
```sql
SELECT id, name, price
    AVG (price) OVER (ORDER BY id
                        ROWS 2 PRECEDING) AS moving_avg
FROM products;
```
上記のSQLでは「2行前」までの平均を集計するというフレーム指定となる。
そのため、結果はこのようになる。
|id|name|price|moving_avg|
|--|--|--|--|
|1|フォーク|500|500 // 500/1|
|2|包丁|3000|1750 // 500+3000/2|
|3|まな板|880|1460 // 500+3000+880/3 |
|4|シャツ|1000|1626 // 3000+880+1000/3|
|5|パンツ|3000|1626 // 880+1000+3000/3|
|6|コピー用紙|600|1533 // 1000+3000+600/3|
|7|ボールペン|100|1233 // 3000+600+100/3|

このような集計方法を**移動平均**と呼ぶ。
「ここ最近の調子」を把握する場合に便利。
<br>

## 所管
使い所が難しそうだが、とりあえずはランク付けか累計を表示したい時に使うと考えとくと良いか？

## 参考
[ゼロからはじめるデータベース操作 SQL : 265~278P]https://www.amazon.co.jp/SQL-%E7%AC%AC2%E7%89%88-%E3%82%BC%E3%83%AD%E3%81%8B%E3%82%89%E3%81%AF%E3%81%98%E3%82%81%E3%82%8B%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9%E6%93%8D%E4%BD%9C-%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E5%AD%A6%E7%BF%92%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA-%E3%83%9F%E3%83%83%E3%82%AF/dp/4798144452
